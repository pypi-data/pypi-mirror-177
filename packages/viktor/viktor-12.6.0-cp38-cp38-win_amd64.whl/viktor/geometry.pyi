import abc
import numpy as np
import uuid
from .core import Color as Color, ISCLOSE_ATOL as ISCLOSE_ATOL, ISCLOSE_RTOL as ISCLOSE_RTOL
from abc import ABC, abstractmethod
from munch import Munch as Munch
from typing import Any, List, Optional, Sequence, TextIO, Tuple, TypeVar, Union

logger: Any
T = TypeVar('T')

class VisualisationError(Exception): ...

class Vector:
    x: Any = ...
    y: Any = ...
    z: Any = ...
    def __init__(self, x: float, y: float, z: float=...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __neg__(self) -> Vector: ...
    def __add__(self, other: Vector) -> Vector: ...
    def __sub__(self, other: Vector) -> Vector: ...
    def __mul__(self, other: float) -> Vector: ...
    def __rmul__(self, other: float) -> Vector: ...
    @property
    def squared_magnitude(self) -> float: ...
    @property
    def magnitude(self) -> float: ...
    @property
    def coordinates(self) -> Tuple[float, float, float]: ...
    def normalize(self) -> Vector: ...
    def dot(self, other: Vector) -> float: ...
    def cross(self, other: Vector) -> Vector: ...

class Material:
    uuid: Any = ...
    color: Any = ...
    def __init__(self, name: str, density: float=..., price: float=..., *, threejs_type: str=..., threejs_roughness: float=..., threejs_metalness: float=..., threejs_opacity: float=..., color: Color=...) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def density(self) -> Optional[float]: ...
    @density.setter
    def density(self, value: float) -> None: ...
    @property
    def price(self) -> Optional[float]: ...
    @price.setter
    def price(self, value: float) -> None: ...

class TransformableObject(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def translate(self, translation_vector: Union[Vector, Tuple[float, float, float]]) -> TransformableObject: ...
    def rotate(self, angle: float, direction: Union[Vector, Tuple[float, float, float]], point: Union[Point, Tuple[float, float, float]]=...) -> TransformableObject: ...
    def mirror(self, point: Union[Point, Tuple[float, float, float]], normal: Union[Vector, Tuple[float, float, float]]) -> TransformableObject: ...
    def scale(self, scaling_vector: Union[Vector, Tuple[float, float, float]]) -> TransformableObject: ...

class _Threejs:
    standard_material_uuid: Any = ...
    @staticmethod
    def metadata() -> dict: ...
    @staticmethod
    def standard_material() -> dict: ...
    @staticmethod
    def geometry_object(name: str, matrix: np.ndarray, geometry_uuid: uuid.UUID, material_uuid: uuid.UUID) -> dict: ...
    @staticmethod
    def group_object(_uuid: uuid.UUID, matrix: np.ndarray) -> dict: ...
    @staticmethod
    def geometry_from_triangle_vertices_faces(_uuid: uuid.UUID, vertices: List[List[float]], faces: List[List[int]]) -> dict: ...
    def __init__(self, group: Group) -> None: ...
    def export(self) -> dict: ...

class Group(TransformableObject):
    def __init__(self, objects: Sequence[Union[Group, TransformableObject]]) -> None: ...
    def add(self, objects: Union[list, tuple, TransformableObject]) -> None: ...
    @property
    def children(self) -> List[Union[Group, TransformableObject]]: ...
    def duplicate(self) -> Group: ...

class Point:
    def __init__(self, x: float, y: float, z: float=...) -> None: ...
    @property
    def coordinates(self) -> np.ndarray: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    def copy(self) -> Point: ...
    def coincides_with(self, other: Point) -> bool: ...
    def vector_to(self, point: Point) -> Vector: ...
    def get_local_coordinates(self, local_origin: Point, spherical: bool=...) -> np.ndarray: ...

class Line:
    def __init__(self, start_point: Point, end_point: Point) -> None: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def length(self) -> float: ...
    def direction(self, normalize: bool=...) -> Vector: ...
    def collinear(self, point: Point) -> bool: ...
    @property
    def length_vector(self) -> np.ndarray: ...
    @property
    def unit_vector(self) -> np.ndarray: ...
    @property
    def geometries(self) -> Tuple[Point, Point]: ...
    @property
    def horizontal(self) -> bool: ...
    @property
    def vertical(self) -> bool: ...
    def discretize(self, num: int=...) -> List[Point]: ...
    def revolve(self, *, material: Material=..., **kwargs: Any) -> LineRevolve: ...
    def get_line_function_parameters(self) -> Tuple[float, float]: ...
    def find_overlap(self, other: Line, inclusive: bool=...) -> Optional[Union[Point, Line]]: ...

def calculate_intersection_bounded_line_with_y(line: Line, y_intersection: float) -> Optional[float]: ...
def calculate_intersection_extended_line_with_y(line: Line, y_intersection: float) -> float: ...
def line_is_horizontal(line: Line) -> bool: ...
def line_is_vertical(line: Line) -> bool: ...
def x_between_bounds(x: float, x1: float, x2: float, inclusive: bool=...) -> bool: ...
def y_between_bounds(y: float, y1: float, y2: float, inclusive: bool=...) -> bool: ...
def point_is_on_bounded_line(point: Point, line: Line, inclusive: bool=...) -> bool: ...
def calculate_intersection_extended_line_with_x(line: Line, x: float) -> Point: ...
def get_line_function_parameters(line: Line) -> Tuple[float, float]: ...
def calculate_intersection_extended_lines(extended_line1: Line, extended_line2: Line) -> Union[Point, None]: ...
def calculate_intersection_bounded_line_extended_line(bounded_line: Line, extended_line: Line, inclusive: bool=...) -> Union[Point, None]: ...
def calculate_intersection_bounded_lines(bounded_line1: Line, bounded_line2: Line, inclusive: bool=...) -> Union[Point, None]: ...

class Revolve(TransformableObject, ABC, metaclass=abc.ABCMeta):
    def __init__(self, *args: Any, material: Material=..., **kwargs: Any) -> None: ...
    @property
    @abstractmethod
    def surface_area(self) -> float: ...
    @property
    @abstractmethod
    def inner_volume(self) -> float: ...
    @property
    def thickness(self) -> float: ...
    @thickness.setter
    def thickness(self, thickness: float) -> None: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, material: Material) -> None: ...
    @property
    def mass(self) -> float: ...

class LineRevolve(Revolve):
    def __init__(self, line: Line, *args: Any, material: Material=..., **kwargs: Any) -> None: ...
    @property
    def line(self) -> Line: ...
    @property
    def uuid(self) -> uuid.UUID: ...
    @property
    def height(self) -> float: ...
    @property
    def surface_area(self) -> float: ...
    @property
    def inner_volume(self) -> float: ...
    @property
    def geometries(self) -> Tuple[Line, ...]: ...

class Arc:
    def __init__(self, centre_point: Point, start_point: Point, end_point: Point, short_arc: bool=...) -> None: ...
    @property
    def radius(self) -> float: ...
    @property
    def centre_point(self) -> Point: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def theta1(self) -> float: ...
    @property
    def theta2(self) -> float: ...
    @property
    def short_arc(self) -> bool: ...
    @property
    def geometries(self) -> Tuple[Point, Point, Point]: ...
    @property
    def angle(self) -> float: ...
    @property
    def length(self) -> float: ...
    @property
    def theta1_theta2(self) -> Tuple[float, float]: ...
    def discretize(self, num: int=...) -> List[Point]: ...
    def revolve(self, *, material: Material=..., **kwargs: Any) -> ArcRevolve: ...

class ArcRevolve(Revolve):
    def __init__(self, arc: Arc, *args: Any, material: Material=..., **kwargs: Any) -> None: ...
    @property
    def arc(self) -> Arc: ...
    @property
    def uuid(self) -> str: ...
    @property
    def surface_area(self) -> float: ...
    @property
    def inner_volume(self) -> float: ...
    @property
    def height(self) -> float: ...
    @property
    def geometries(self) -> Tuple[Arc, ...]: ...

class Triangle:
    profile: Any = ...
    vertices: Any = ...
    def __init__(self, point1: Point, point2: Point, point3: Point) -> None: ...
    def area(self) -> float: ...
    @property
    def centroid(self) -> Tuple[float, float, float]: ...
    @property
    def moment_of_inertia(self) -> Tuple[float, float]: ...

class CartesianAxes(Group):
    def __init__(self, origin: Point=..., axis_length: float=..., axis_diameter: float=...) -> None: ...

class RDWGSConverter:
    X0: int = ...
    Y0: int = ...
    phi0: float = ...
    lam0: float = ...
    @staticmethod
    def from_rd_to_wgs(coords: Tuple[float, float]) -> List[float]: ...
    @staticmethod
    def from_wgs_to_rd(coords: Tuple[float, float]) -> List[float]: ...

def spherical_to_cartesian(spherical_coordinates: Tuple[float, float, float]) -> np.ndarray: ...
def cartesian_to_spherical(cartesian_coordinates: Tuple[float, float, float]) -> np.ndarray: ...
def cylindrical_to_cartesian(cylindrical_coordinates: Tuple[float, float, float]) -> np.ndarray: ...
def cartesian_to_cylindrical(cartesian_coordinates: Tuple[float, float, float]) -> np.ndarray: ...

class Extrusion(Group):
    def __init__(self, profile: List[Point], line: Line, profile_rotation: float=..., *, material: Material=...) -> None: ...
    @property
    def children(self) -> None: ...
    @property
    def profile(self) -> List[Point]: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, material: Material) -> None: ...
    @property
    def line(self) -> Line: ...
    @property
    def uuid(self) -> str: ...
    @property
    def length(self) -> float: ...
    @property
    def geometries(self) -> Line: ...
    @property
    def transformation(self) -> np.ndarray: ...

class ArcExtrusion(Group):
    def __init__(self, profile: List[Point], arc: Arc, profile_rotation: float=..., n_segments: int=..., *, material: Material=...) -> None: ...
    @property
    def children(self) -> None: ...

class CircularExtrusion(TransformableObject):
    def __init__(self, diameter: float, line: Line, *, open_ends: bool=..., material: Material=...) -> None: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, material: Material) -> None: ...
    @property
    def line(self) -> Line: ...
    @property
    def length(self) -> float: ...
    @property
    def diameter(self) -> float: ...
    @property
    def radius(self) -> float: ...
    @property
    def cross_sectional_area(self) -> float: ...

class RectangularExtrusion(Extrusion):
    def __init__(self, width: float, height: float, line: Line, profile_rotation: float=..., *, material: Material=...) -> None: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    @property
    def cross_sectional_area(self) -> float: ...
    @property
    def inner_volume(self) -> float: ...

class SquareBeam(RectangularExtrusion):
    def __init__(self, length_x: float, length_y: float, length_z: float, *, material: Material=...) -> None: ...

def points_are_coplanar(points: List[Point]) -> bool: ...
def lines_in_same_plane(line1: Line, line2: Line) -> bool: ...
def calculate_distance_vector(start_point: Point, end_point: Point) -> np.ndarray: ...
def convert_points_for_lathe(points: Sequence[Point]) -> List[dict]: ...
def translation_matrix(direction: Union[Vector, Tuple[float, float, float]]) -> np.ndarray: ...
def scaling_matrix(scaling_vector: Union[Vector, Tuple[float, float, float]]) -> np.ndarray: ...
def rotation_matrix(angle: float, direction: Union[Vector, Tuple[float, float, float]], point: Union[Point, Tuple[float, float, float]]=...) -> np.ndarray: ...
def reflection_matrix(point: Union[Point, Tuple[float, float, float]], normal: Union[Vector, Tuple[float, float, float]]) -> np.ndarray: ...
def unit_vector(data: Any, axis: int=..., out: Any=...) -> np.ndarray: ...
def mirror_object(obj: TransformableObject, point: Point, normal: Union[Vector, Tuple[float, float, float]]) -> TransformableObject: ...
def volume_cone(r: float, h: float) -> float: ...
def surface_cone_without_base(r: float, h: float) -> float: ...
def surface_area_dome(theta1: float, theta2: float, r: float, R: float) -> float: ...
def hex_to_rgb(value: str) -> Tuple[int, ...]: ...
def rgb_to_hex(red: int, green: int, blue: int, include_hashtag: bool=...) -> str: ...
def circumference_is_clockwise(circumference: List[Point]) -> bool: ...
def add_point(unique_points: List[Point], point: Point) -> Tuple[List[Point], int]: ...
def get_vertices_faces(triangles: List[Triangle]) -> Tuple[list, list]: ...
def find_overlap(region_a: Tuple[float, float], region_b: Tuple[float, float], inclusive: bool=...) -> Union[None, Tuple[float, float]]: ...

class Pattern(Group):
    base_object: Any = ...
    def __init__(self, base_object: TransformableObject, duplicate_translation_list: List[List[float]]) -> None: ...

class LinearPattern(Pattern):
    def __init__(self, base_object: TransformableObject, direction: List[float], number_of_elements: int, spacing: float) -> None: ...

class BidirectionalPattern(Pattern):
    def __init__(self, base_object: TransformableObject, direction_1: List[float], direction_2: List[float], number_of_elements_1: int, number_of_elements_2: int, spacing_1: float, spacing_2: float) -> None: ...

class Polygon(TransformableObject):
    points: Any = ...
    def __init__(self, points: List[Point], *, surface_orientation: bool=..., material: Material=..., skip_duplicate_vertices_check: bool=...) -> None: ...
    def has_clockwise_circumference(self) -> bool: ...
    @property
    def material(self) -> Material: ...
    @property
    def cross_sectional_area(self) -> float: ...
    @property
    def centroid(self) -> Tuple[float, float]: ...
    @property
    def moment_of_inertia(self) -> Tuple[float, float]: ...
    @material.setter
    def material(self, material: Material) -> None: ...

class Polyline:
    points: Any = ...
    def __init__(self, points: List[Point]) -> None: ...
    @classmethod
    def from_lines(cls: Any, lines: Sequence[Line]) -> Polyline: ...
    def is_equal_to(self, other: Polyline) -> bool: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def lines(self) -> List[Line]: ...
    @property
    def x_min(self) -> Optional[float]: ...
    @property
    def x_max(self) -> Optional[float]: ...
    @property
    def y_min(self) -> Optional[float]: ...
    @property
    def y_max(self) -> Optional[float]: ...
    @property
    def z_min(self) -> Optional[float]: ...
    @property
    def z_max(self) -> Optional[float]: ...
    def get_reversed_polyline(self) -> Polyline: ...
    def serialize(self) -> list: ...
    @classmethod
    def from_dict(cls: Any, polyline_dict: Union[dict, Munch]) -> Polyline: ...
    def filter_duplicate_points(self) -> Polyline: ...
    def is_monotonic_ascending_x(self, strict: bool=...) -> bool: ...
    def is_monotonic_ascending_y(self, strict: bool=...) -> bool: ...
    def intersections_with_polyline(self, other_polyline: Polyline) -> List[Point]: ...
    def intersections_with_x_location(self, x: float) -> List[Point]: ...
    def point_is_on_polyline(self, point: Point) -> bool: ...
    def get_polyline_between(self, start_point: Point, end_point: Point, inclusive: bool=...) -> Polyline: ...
    def find_overlaps(self, other: Polyline) -> List[Polyline]: ...
    def combine_with(self, other: Polyline) -> Polyline: ...
    def split(self, point: Point) -> Tuple[Polyline, Polyline]: ...
    @classmethod
    def get_lowest_or_highest_profile_x(cls: Any, profile_1: Polyline, profile_2: Polyline, lowest: bool) -> Polyline: ...

class Cone(TransformableObject):
    def __init__(self, diameter: float, height: float, *, origin: Point=..., orientation: Vector=..., material: Material=...) -> None: ...
    @classmethod
    def from_line(cls: Any, diameter: float, line: Line, *, material: Material=...) -> Cone: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, material: Material) -> None: ...

class Sphere(TransformableObject):
    centre_point: Any = ...
    radius: Any = ...
    width_segments: Any = ...
    height_segments: Any = ...
    material: Any = ...
    def __init__(self, centre_point: Point, radius: float, width_segments: float=..., height_segments: float=..., material: Material=...) -> None: ...
    def diameter(self) -> float: ...
    def circumference(self) -> float: ...
    def surface_area(self) -> float: ...
    def volume(self) -> float: ...

class Torus(Group):
    def __init__(self, radius_cross_section: float, radius_rotation_axis: float, rotation_angle: float=..., *, material: Material=...) -> None: ...
    @property
    def children(self) -> None: ...
    @property
    def inner_volume(self) -> float: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> None: ...

class TriangleAssembly(TransformableObject):
    material: Any = ...
    def __init__(self, triangles: List[Triangle], *, material: Material=..., skip_duplicate_vertices_check: bool=...) -> None: ...

class GeoPoint:
    lat: Any = ...
    lon: Any = ...
    def __init__(self, lat: float, lon: float) -> None: ...
    @classmethod
    def from_rd(cls: Any, coords: Tuple[float, float]) -> GeoPoint: ...
    @property
    def rd(self) -> Tuple[float, float]: ...

class GeoPolyline:
    def __init__(self, *points: GeoPoint) -> None: ...
    @property
    def points(self) -> List[GeoPoint]: ...

class GeoPolygon:
    def __init__(self, *points: GeoPoint) -> None: ...
    @property
    def points(self) -> List[GeoPoint]: ...

class _Mesh(TransformableObject):
    material: Any = ...
    def __init__(self, vertices: List[List[float]], faces: List[List[int]], material: Material=...) -> None: ...
    @classmethod
    def from_obj(cls: Any, file: TextIO, material: Material=...) -> _Mesh: ...

class _MeshAssembly(Group):
    def __init__(self, meshes: List[_Mesh]) -> None: ...
    @classmethod
    def from_obj(cls: Any, file: TextIO, material_library: TextIO=..., default_material: Material=...) -> _MeshAssembly: ...
