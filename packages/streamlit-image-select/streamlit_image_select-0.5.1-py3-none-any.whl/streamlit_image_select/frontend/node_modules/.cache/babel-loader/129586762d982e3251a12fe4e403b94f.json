{"ast":null,"code":"import { Streamlit } from \"streamlit-component-lib\"; // Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\n\nconst span = document.body.appendChild(document.createElement(\"span\"));\nconst textNode = span.appendChild(document.createTextNode(\"\"));\nconst button = span.appendChild(document.createElement(\"button\"));\nbutton.textContent = \"Click Me!\"; // Add a click handler to our button. It will send data back to Streamlit.\n\nlet selectedImage = \"\"; // let numClicks = 0\n// let isFocused = false\n// button.onclick = function(): void {\n//   // Increment numClicks, and pass the new value back to\n//   // Streamlit via `Streamlit.setComponentValue`.\n//   numClicks += 1\n//   Streamlit.setComponentValue(numClicks)\n// }\n// button.onfocus = function(): void {\n//   isFocused = true\n// }\n// button.onblur = function(): void {\n//   isFocused = false\n// }\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\n\nfunction onRender(event) {\n  // Get the RenderData from the event\n  const data = event.detail; // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n  // if (data.theme) {\n  //   // Use CSS vars to style our button border. Alternatively, the theme style\n  //   // is defined in the data.theme object.\n  //   const borderStyling = `1px solid var(${\n  //     isFocused ? \"--primary-color\" : \"gray\"\n  //   })`\n  //   button.style.border = borderStyling\n  //   button.style.outline = borderStyling\n  // }\n  // Disable our button if necessary.\n  // button.disabled = data.disabled\n  // RenderData.args is the JSON dictionary of arguments sent from the\n  // Python script.\n\n  let name = data.args[\"name\"]; // Show \"Hello, name!\" with a non-breaking space afterwards.\n\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160); // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n\n  Streamlit.setFrameHeight();\n} // Attach our `onRender` handler to Streamlit's render event.\n\n\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender); // Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\n\nStreamlit.setComponentReady(); // Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\n\nStreamlit.setFrameHeight();","map":{"version":3,"names":["Streamlit","span","document","body","appendChild","createElement","textNode","createTextNode","button","textContent","selectedImage","onRender","event","data","detail","name","args","String","fromCharCode","setFrameHeight","events","addEventListener","RENDER_EVENT","setComponentReady"],"sources":["/Users/jrieke/Desktop/component-template/template-reactless/my_component/frontend/src/index.tsx"],"sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\n// Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\nconst span = document.body.appendChild(document.createElement(\"span\"))\nconst textNode = span.appendChild(document.createTextNode(\"\"))\nconst button = span.appendChild(document.createElement(\"button\"))\nbutton.textContent = \"Click Me!\"\n\n// Add a click handler to our button. It will send data back to Streamlit.\nlet selectedImage = \"\"\n// let numClicks = 0\n// let isFocused = false\n// button.onclick = function(): void {\n//   // Increment numClicks, and pass the new value back to\n//   // Streamlit via `Streamlit.setComponentValue`.\n//   numClicks += 1\n//   Streamlit.setComponentValue(numClicks)\n// }\n\n// button.onfocus = function(): void {\n//   isFocused = true\n// }\n\n// button.onblur = function(): void {\n//   isFocused = false\n// }\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n  // if (data.theme) {\n  //   // Use CSS vars to style our button border. Alternatively, the theme style\n  //   // is defined in the data.theme object.\n  //   const borderStyling = `1px solid var(${\n  //     isFocused ? \"--primary-color\" : \"gray\"\n  //   })`\n  //   button.style.border = borderStyling\n  //   button.style.outline = borderStyling\n  // }\n\n  // Disable our button if necessary.\n  // button.disabled = data.disabled\n\n  // RenderData.args is the JSON dictionary of arguments sent from the\n  // Python script.\n  let name = data.args[\"name\"]\n\n  // Show \"Hello, name!\" with a non-breaking space afterwards.\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160)\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"mappings":"AAAA,SAASA,SAAT,QAAsC,yBAAtC,C,CAEA;AACA;;AACA,MAAMC,IAAI,GAAGC,QAAQ,CAACC,IAAT,CAAcC,WAAd,CAA0BF,QAAQ,CAACG,aAAT,CAAuB,MAAvB,CAA1B,CAAb;AACA,MAAMC,QAAQ,GAAGL,IAAI,CAACG,WAAL,CAAiBF,QAAQ,CAACK,cAAT,CAAwB,EAAxB,CAAjB,CAAjB;AACA,MAAMC,MAAM,GAAGP,IAAI,CAACG,WAAL,CAAiBF,QAAQ,CAACG,aAAT,CAAuB,QAAvB,CAAjB,CAAf;AACAG,MAAM,CAACC,WAAP,GAAqB,WAArB,C,CAEA;;AACA,IAAIC,aAAa,GAAG,EAApB,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,CAAkBC,KAAlB,EAAsC;EACpC;EACA,MAAMC,IAAI,GAAID,KAAD,CAAmCE,MAAhD,CAFoC,CAIpC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EAEA;EACA;;EACA,IAAIC,IAAI,GAAGF,IAAI,CAACG,IAAL,CAAU,MAAV,CAAX,CArBoC,CAuBpC;;EACAV,QAAQ,CAACG,WAAT,GAAwB,UAASM,IAAK,IAAf,GAAqBE,MAAM,CAACC,YAAP,CAAoB,GAApB,CAA5C,CAxBoC,CA0BpC;EACA;EACA;EACA;;EACAlB,SAAS,CAACmB,cAAV;AACD,C,CAED;;;AACAnB,SAAS,CAACoB,MAAV,CAAiBC,gBAAjB,CAAkCrB,SAAS,CAACsB,YAA5C,EAA0DX,QAA1D,E,CAEA;AACA;;AACAX,SAAS,CAACuB,iBAAV,G,CAEA;AACA;;AACAvB,SAAS,CAACmB,cAAV"},"metadata":{},"sourceType":"module"}