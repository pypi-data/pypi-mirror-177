import json_cpp2_core
import json_cpp2


class JsonList(list, json_cpp2.JsonParsable):
    """
    Provides json translation for iterable types.
    """

    def __init__(self, list_type: type = None, iterable = None, allow_null_values: bool = True):
        if list_type and not isinstance(list_type, type):
            raise TypeError("list_type must be a type")

        if iterable and not hasattr(iterable, '__getitem__'):
            raise Exception("iterable must be an iterable")

        list.__init__(self)
        self._list_type = list_type
        self._allow_null_values = allow_null_values
        if iterable:
            for i in iterable:
                self.append(i)

    @staticmethod
    def create_class(name: str = None,
                     list_type: type = None,
                     iterable=None,
                     allow_null_values: bool = True) -> type:
        """
        Creates a new type with a JsonList specification

        :param name: name of the class to be created. if empty, an autogenerated name will be provided
        :type name:  str
        :param list_type: supported type. if empty, the list will allow elements from any supported type
        :type list_type: supported type
        :param iterable: initial values for every new instance of the class. if empty, the list will be initialized empty
        :type iterable: iterable
        :param allow_null_values: allows the list to hold null values. they will be translated to None. default is True
        :type allow_null_values: bool
        :return: the new type
        :rtype: type
        :Example:

        >>> IntList = JsonList.create_class(list_type=int, iterable=[1,2,3])
        >>> l = IntList()
        >>> l.append(4)
        >>> l
        [1, 2, 3, 4]
        >>> l.append("a string")
        Traceback (most recent call last):
         ...
        TypeError: value of wrong type: expected <class 'int'>, received <class 'str'>
        """
        if name is None:
            from string import ascii_lowercase
            from random import choice
            name = ''.join(choice(ascii_lowercase) for i in range(10))

        def __init__(self):
            JsonList.__init__(self,
                              list_type=list_type,
                              iterable=iterable,
                              allow_null_values=allow_null_values)
        return type(name, (JsonList,), {"__init__": __init__})

    def __get_descriptor__(self):
        json_descriptor = json_cpp2_core.JsonListDescriptor()
        json_descriptor.allow_null_values = self._allow_null_values
        if self._list_type:
            self._item_descriptor = json_cpp2.JsonParser.__create_descriptor__(self._list_type)
            json_descriptor.set_item_descriptor(self._item_descriptor)
        for i in self:
            json_descriptor.__iadd__(json_cpp2.JsonParser.__create_descriptor__(i))
        return json_descriptor

    def __from_descriptor__(self, json_descriptor: json_cpp2_core.JsonListDescriptor):
        self.clear()
        for i in range(len(json_descriptor)):
            v = json_cpp2.JsonParser.__get_value__(json_descriptor[i])
            self.append(v)
        return self

    def load(self, json_string: str) -> json_cpp2.JsonParsable:
        """
        Parses a json_string and loads the values into the list, validating type and nullability

        :param json_string: valid json string
        :return: the list itself
        :Example:
        >>> l = JsonList()
        >>> l.load('[1,null,"hello",4,{"x":10,"y":20}]')
        [1, None, 'hello', 4, {"x":10,"y":20}]
        >>> print(l[4].x)
        10
        """
        json_descriptor = self.__get_descriptor__()
        json_descriptor.from_json(json_string)
        self.__from_descriptor__(json_descriptor)
        return self

    def __type_check__(self, value):
        if value is None:
            if not self._allow_null_values:
                raise RuntimeError("list cannot contain null values when allow_null_values is set to false")
        elif self._list_type and not isinstance(value, self._list_type):
            raise TypeError("value of wrong type: expected %s, received %s" % (str(self._list_type), str(type(value))))
        json_cpp2.JsonParser.check_supported_type(value)

    def append(self, item) -> None:
        """
        Validates type and nullability and adds the element to the list

        :raises TypeError: when item is of the wrong type
        :raises RuntimeError: when item is null and allow_null_values is set to False
        :param item: value to be added to the list
        :type item: any

        :return: None
        :rtype: None
        :Example:

        >>> l = JsonList(int, allow_null_values=False)
        >>> l.append(1)
        >>> l.append(2)
        >>> l.append(3)
        >>> print(l)
        [1,2,3]
        """
        self.__type_check__(item)
        list.append(self, item)

    def to_file(self, file_path: str) -> None:
        """
        Saves the list to a file in json format

        :param file_path: path to the file
        :type file_path: str
        :rtype: None
        :Example:

        >>> l = JsonList(int)
        >>> l.append(1)
        >>> l.append(2)
        >>> l.append(3)
        >>> l.to_file("data.json")
        >>> open('data.json','r').read()
        '[1,2,3]'
        """
        json_cpp2.JsonParser.to_file(self, file_path)

    def __iadd__(self, other):
        for item in other:
            self.append(item)
        return self

    def __add__(self, other):
        new_list = JsonList(list_type=self._list_type, iterable=self)
        for item in other:
            new_list.append(item)
        return new_list

    def __radd__(self, other):
        new_list = JsonList(list_type=self._list_type, iterable=other)
        for item in self:
            new_list.append(item)
        return new_list

    def __str__(self):
        return str(self.__get_descriptor__())

    def __setitem__(self, key, value):
        self.__type_check__(value)
        list.__setitem__(self, key, value)

    def __setslice__(self, i, j, iterable):
        for index, value in enumerate(iterable):
            self.__setitem__(index + i, value)

    def map(self, item_function):
        """
        Executes a function on every element of the list and saves the results into a new list.

        :param item_function: the name of the member to be copied to the new list
        :type item_function: callable
        :return: a JsonList with the results
        :rtype: JsonList
        :Example:

        >>> from json_cpp2 import JsonObject
        >>> l = JsonList(JsonObject)
        >>> l.append(JsonObject(x=10, y=15))
        >>> l.append(JsonObject(x=20, y=25))
        >>> l.append(JsonObject(x=30, y=35))
        >>> l.map(lambda i: i.x + i.y)
        [25, 45, 65]
        >>> l.map(lambda i: i.x - 5)
        [5, 15, 25]
        >>> l.map(lambda i: int((i.x ** 2 + i.y ** 2) ** .5))
        [18, 32, 46]
        """
        if not callable(item_function):
            raise TypeError("incorrect parameter: expected member name or callable")
        new_list = JsonList()
        for item in self:
            new_list.append(item_function(item))
        return new_list

    def get(self, member_name:str) -> json_cpp2.JsonParsable:
        """
        Copies a member from on every element of the list into a new list.

        :param member_name: the name of the member to be copied to the new list
        :type member_name: str
        :return: a JsonList with the results
        :rtype: JsonList
        :Example:

        >>> from json_cpp2 import JsonObject
        >>> l = JsonList(JsonObject)
        >>> l.append(JsonObject(x=10, y=15))
        >>> l.append(JsonObject(x=20, y=25))
        >>> l.append(JsonObject(x=30, y=35))
        >>> l.get('x')
        [10, 20, 30]
        >>> l.get('y')
        [15, 25, 35]
        """
        if not issubclass(self._list_type, json_cpp2.JsonObject):
            raise TypeError("get can only be used with json_object list types")
        if len(self) == 0:
            return JsonList()
        new_list = JsonList()
        for i in self:
            new_list.append(i[member_name])
        return new_list

    def select(self, member_names) -> json_cpp2.JsonParsable:
        """
        Creates a list of objects with new objects of a new type containing with a subset of members from the originals

        :param member_names: list of member to be included in the new list
        :type member_names: list of str
        :return: the new list of objects of the new type
        :rtype: JsonList
        :Example:
        >>> from json_cpp2 import JsonObject
        >>> l = JsonList(JsonObject)
        >>> l.append(JsonObject(x=10, y=15, z=5))
        >>> l.append(JsonObject(x=20, y=25, z=5))
        >>> l.append(JsonObject(x=30, y=35, z=5))
        >>> l.select(["x","y"])
        [{"x":10,"y":15}, {"x":20,"y":25}, {"x":30,"y":35}]

        """
        if self._list_type is not self._list_type and not issubclass(self._list_type, json_cpp2.JsonObject):
            raise TypeError("select can only be used with json_object list types")

        if len(self) == 0:
            return JsonList()

        new_list = JsonList(json_cpp2.JsonObject)
        for i in self:
            new_list.append(i.select(member_names))
        return new_list

    def where(self, lambda_criteria) -> json_cpp2.JsonParsable:
        """
        Creates a list with elements that passes a criteria

        :param lambda_criteria: lambda receiving each element and returning a bool
        :type lambda_criteria: lambda
        :return: the new list
        :rtype: JsonList

        """
        nl = JsonList(self._list_type)
        for i in self:
            if lambda_criteria(i):
                nl.append(i)
        return nl

    def __copy__(self):
        new_list = type(self)()
        new_list._list_type = self._list_type
        for item in self:
            new_list.append(item)
        return new_list

    def __deepcopy__(self, memo):
        from copy import deepcopy
        new_list = type(self)()
        memo[id(self)] = new_list
        new_list._list_type = self._list_type
        for item in self:
            new_list.append(deepcopy(item))
        return new_list


if __name__ == '__main__':
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)
