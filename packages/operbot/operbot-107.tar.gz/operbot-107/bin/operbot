#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=C0115,C0116,C0209,W0221,W0201,E0611,C0413, W0613


"write your own commands"


__version__ = "107"


import atexit
import importlib
import importlib.util
import os
import readline
import rlcompleter
import sys
import termios
import time
import traceback


sys.path.insert(0, os.getcwd())


from operbot.handler import Callback, Command, Event, Handler
from operbot.handler import command, parse, scan, scandir
from operbot.object import Wd, keys, printable, update
from operbot.run import Cfg
from operbot.thread import name


from operbot import cmds, irc, rss


Wd.workdir = os.path.expanduser("~/.operbot")


starttime = time.time()


scan(cmds)
scan(irc)
scan(rss)


class CLI(Handler):

    def raw(self, txt):
        print(txt)


class Console(CLI):

    def handle(self, event):
        Command.handle(event)
        event.wait()

    def poll(self):
        event = Event()
        event.txt = input("> ")
        event.orig = repr(self)
        return event


class Completer(rlcompleter.Completer):

    def __init__(self, options):
        super().__init__()
        self.matches = []
        self.options = options

    def complete(self, text, state):
        if state == 0:
            if text:
                self.matches = [s for s in self.options if s and s.startswith(text)]
            else:
                self.matches = self.options[:]
        try:
            return self.matches[state]
        except IndexError:
            return None


def banner(cfg):
    print(
          "OPERBOT started at %s %s" % (
                                      time.ctime(time.time()).replace("  ", " "),
                                      printable(cfg, "debug,verbose")
                                     )
         )


def boot():
    setcompleter(keys(Command.cmd))
    txt = ' '.join(sys.argv[1:])
    cfg = parse(txt)
    if "i" in cfg.opts:
        cfg.irc = True
    if "r" in cfg.opts:
        cfg.rss = True
    update(Cfg, cfg)
    return cfg


def from_exception(exc, txt="", sep=" "):
    result = []
    for frm in traceback.extract_tb(exc.__traceback__):
        fnm = os.sep.join(frm.filename.split(os.sep)[-2:])
        result.append(f"{fnm}:{frm.lineno}")
    nme = name(exc)
    res = sep.join(result)
    return f"{txt} {res} {nme}: {exc}".strip()


def importer(pname, mname, path):
    mod = None
    spec = importlib.util.spec_from_file_location(mname, path)
    if spec:
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        scan(mod)
    return mod


def init(pname, mname, path=None):
    mod = importer(pname, mname, path)
    if "init" in dir(mod):
        mod.init()


def setcompleter(optionlist):
    completer = Completer(optionlist)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))


def ver(event):
    event.reply("OPERBOT %s" % __version__)


def wrap(func):
    fds = sys.stdin.fileno()
    gotterm = True
    try:
        old = termios.tcgetattr(fds)
    except termios.error:
        gotterm = False
    readline.redisplay()
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        if gotterm:
            termios.tcsetattr(fds, termios.TCSADRAIN, old)
        for err in Callback.errors:
            print(from_exception(err))


def main():
    cfg = boot()
    scandir("mod", importer)
    Command.add(ver)
    if cfg.txt:
        cli = CLI()
        return command(cli, cfg.otxt)
    if not Cfg.exec:
        banner(Cfg)
        scandir("mod", init)
        bot = irc.init()
        print(printable(bot.cfg, "nick,channel,server,port,sasl"))
        rss.init()
        csl = Console()
        csl.start()
        csl.wait()


wrap(main)
 